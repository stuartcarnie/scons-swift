#!/usr/bin/env python
from utils.scons_hints import *

# Import the environment from parent
Import('env')

# Clone the environment to avoid modifying the global one
env = env.Clone()

# Configure C++ standard and optimizations
env.Append(CXXFLAGS=['-std=c++17', '-O3', '-DNDEBUG', '-march=native'])
env.Append(LINKFLAGS=['-O3'])

# Add both the source directory and build directory to include paths
env.Append(CPPPATH=['.', '#build/cpp_calls_swift'])

# Configure Swift optimizations
env.Append(SWIFTFLAGS=['-O', '-whole-module-optimization'])

# Build the Swift module with the new SwiftModule builder
# This will generate SwiftLibrary.swiftmodule and SwiftLibrary-Swift.h
swift_module = env.SwiftModule('SwiftLibrary', source=['swift_library.swift'])

# The C++ files depend on the Swift module being built first (to generate the header)
# Build the C++ main that uses Swift
cpp_main = env.Object('main.cpp')
env.Depends(cpp_main, swift_module)

# Build benchmark
cpp_benchmark = env.Object('benchmark.cpp')
env.Depends(cpp_benchmark, swift_module)

# For linking, we need the object file from the Swift compilation
# The SwiftModule builder creates a .swiftmodule, but we need to compile to object for linking
swift_obj = env.Object('swift_library.swift')

# Link everything together
program = env.Program('cpp_calls_swift', [cpp_main, swift_obj])
benchmark_program = env.Program('benchmark', [cpp_benchmark, swift_obj])

# Return the built targets
Return('program', 'benchmark_program')
